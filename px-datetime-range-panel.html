<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../px-calendar-picker/px-calendar-picker.html"/>
<link rel="import" href="../px-datetime-common/px-datetime-presets.html"/>
<link rel="import" href="../px-datetime-common/px-datetime-buttons.html"/>
<link rel="import" href="../px-datetime-common/px-datetime-imports.html"/>
<link rel="import" href="../px-datetime-common/px-datetime-range-behavior.html"/>

<!--
Rangepicker modal component.

##### Usage

    <px-datetime-range-panel from={{...}} to={{...}}>
    </px-datetime-range-panel>
-->
<dom-module id="px-datetime-range-panel">
  <link rel="import" type="css" href="css/px-datetime-range-panel.css"/>
  <template>
    <div class=overlay></div>
    <div id="rangepickerModal" class="rangepicker__box">
      <div class="flex">
        <div class="flex--item rangepicker__box__calendar">
          <px-calendar-picker
          id="from"
          hide-next-button="{{_areConsecutiveMonth(fromBaseDate, toBaseDate)}}"
          is-utc="{{isUtc}}"
          allow-future-dates="{{allowFutureDates}}"
          base-date="{{fromBaseDate}}">
          </px-calendar-picker>
        </div>
        <template is="dom-if" if="{{!_areConsecutiveMonth(fromBaseDate, toBaseDate)}}">
          <div class="divider flex--item">
          </div>
        </template>
        <div class="flex--item rangepicker__box__calendar">
          <px-calendar-picker
            id="to"
            is-utc="{{isUtc}}"
            hide-previous-button="{{_areConsecutiveMonth(fromBaseDate, toBaseDate)}}"
            allow-future-dates="{{allowFutureDates}}"
            base-date="{{toBaseDate}}">
          </px-calendar-picker>
        </div>
        <template is="dom-if" if="{{!hidePresets}}">
          <px-datetime-presets id="presets" class="flex flex--col border--left u-p+" preset-ranges="{{presetRanges}}">
          </px-datetime-presets>
        </template>
      </div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-datetime-range-panel',
    behaviors: [pxDatetimeRangeBehavior],

    properties: {

      /**
       * (optional)
       *
       * Reflects the date currently used by the 'from' calendar to determine what it should
       * be showing, i.e what month, year or year range. ISO8601 string
       *
       * @default 1 month before now
       */
      fromBaseDate: {
        type: String,
        value: function() { return moment().subtract(1,'months').toISOString();},
        observer: '_fromBaseDateChanged'
      },
      /**
       * (optional)
       *
       * Reflects the date currently used by the 'to' calendar to determine what it should
       * be showing, i.e what month, year or year range. ISO8601 string
       *
       * @default now
       */
      toBaseDate: {
        type: String,
        observer: '_toBaseDateChanged'
      },
      /**
       * True if the modal is hidden.  Must be declared as a property to reference (below) in IE 10.
       * @private
       */
      hidden: {
        type: Boolean
      },
      /**
       * (optional)
       * If set the presets won't be shown
       */
      hidePresets: {
        type: Boolean,
        value: false
      },
      /**
       * (optional)
       *
       * The preset date/time ranges to be displayed.
       *
       *```
       *   [
       *    {
       *      "displayText": "Last 5 Minutes",
       *      "startDateTime": "2013-02-04T22:44:30.652Z",
       *      "endDateTime": "2013-02-04T22:49:30.652Z"
       *    },
       *    {
       *      "displayText": "Last 12 Hours",
       *      "startDateTime": "2013-02-04T10:44:30.652Z",
       *      "endDateTime": "2013-02-04T22:49:30.652Z"
       *    }
       *   ]
       * ```
       *
       * @default Today + Yesterday + Last 7 Days + This Month + Last Month
       */
      presetRanges: {
        type: Object,
        value: function() {
          var now = moment();
          return [
            {
              "displayText": "Today",
              "startDateTime": now,
              "endDateTime": now
            },
            {
              "displayText": "Yesterday",
              "startDateTime": now.clone().subtract(1, 'day'),
              "endDateTime": now.clone().subtract(1, 'day')
            },
            {
              "displayText": "Last 7 Days",
              "startDateTime": now.clone().subtract(7, 'days'),
              "endDateTime": now
            },
            {
              "displayText": "This Month",
              "startDateTime": now.clone().startOf('month'),
              "endDateTime": now.clone().endOf('month')
            },
            {
              "displayText": "Last Month",
              "startDateTime": now.clone().subtract(1, 'months').startOf('month'),
              "endDateTime": now.clone().subtract(1, 'months').endOf('month')
            }
          ]
        }
      }
    },
    ready: function() {
      var fromHandler = this._fromPicked.bind(this),
          toHandler = this._toPicked.bind(this),
          presetHandler = this._presetSelected.bind(this);

      this.$.from.addEventListener('px-date-selected', fromHandler);
      this.$.to.addEventListener('px-date-selected', toHandler);
      this.addEventListener('px-preset-selected', presetHandler);

  /*    this.$.rangepickerModal.addEventListener('px-preset-selected', function(e) {
        var presetStartDateTime = e.detail.startDateTime;
        var presetEndDateTime = e.detail.endDateTime;

        if(self.isUtc) {
          if(!self.$.dateRangePicker.secondRangeDate){
            self.$.dateRangePicker.secondRangeDate = moment.utc(presetEndDateTime);
          }
          self.set('from', moment.utc(presetStartDateTime));
          self.set('to', moment.utc(presetEndDateTime));
        }
        else {
          if(!self.$.dateRangePicker.secondRangeDate){
            self.$.dateRangePicker.secondRangeDate = moment(presetEndDateTime);
          }
          self.set('from', moment(presetStartDateTime));
          self.set('to', moment(presetEndDateTime));
        }
        self.$.dateRangePicker._resetVisibleCalendars();
      });*/
    },

    _presetSelected: function(e) {
      var start = moment(e.detail.startDateTime),
          end = moment(e.detail.endDateTime);

      this.$.from.fromMoment = start;
      this.$.from.toMoment = end;
      this.$.to.fromMoment = start;
      this.$.to.toMoment = end;

      this.set('fromMoment', start);
      this.set('toMoment', end);

      this._setRangeFromMoment();
    },

    _resetRange: function(rangeObject) {
      //order maters
      rangeObject.toMoment = null;
      rangeObject.fromMoment = null;
    },

    _rangeIsSelected: function() {
      return this.fromMoment && this.toMoment ;
    },

    _fromPicked: function(event) {

      //reset if needed
      if(this._rangeIsSelected()) {
        this._resetRange(this);
        this._resetRange(this.$.to);
        this._resetRange(this.$.from);
      }

      //nothing selected, assume it's going to be the end date
      if(!this.toMoment && !this.fromMoment) {
        this.$.from.fromMoment = event.detail;
        this.set('fromMoment', event.detail);
      } else {

        if(this.fromMoment) {
          //range is picked solely on 'from' calendar

          //swap dates if needed
          if(event.detail.isBefore(this.fromMoment)) {

            this.set('toMoment', this.fromMoment);
            this.set('fromMoment', event.detail);
          } else {
            this.set('toMoment', event.detail);
          }

          //make sure 'to' calendar is aware of the range as well
          this.$.to.fromMoment = this.fromMoment;
          this.$.to.toMoment = this.toMoment;
        } else {
          //from moment selected from other calendar. Adjust both calendar so they
          //display properly
          this.$.to.toMoment = this.toMoment;
          this.$.to.fromMoment = event.detail;
          this.$.from.toMoment = this.toMoment;
          this.set('fromMoment', event.detail);
        }
        this._setRangeFromMoment();
      }
    },

    _toPicked: function(event) {

      //reset if needed
      if(this._rangeIsSelected()) {
        this._resetRange(this);
        this._resetRange(this.$.from);
        this._resetRange(this.$.to);
      }

      //nothing selected, assume it's going to be the end date
      if(!this.toMoment && !this.fromMoment) {

          this.$.to.fromMoment = event.detail;
          this.set('toMoment', event.detail);
      } else {

        if(this.toMoment) {
          //range is picked solely on 'to' calendar

          //swap dates if needed
          if(event.detail.isAfter(this.toMoment)) {

            this.set('fromMoment', this.toMoment);
            this.set('toMoment', event.detail);
          } else {
            this.set('fromMoment', event.detail);
          }
          //make sure both calendars reflects the right state
          this.$.to.toMoment = this.toMoment;
          this.$.to.fromMoment = this.fromMoment;
          this.$.from.fromMoment = this.fromMoment;
          this.$.from.toMoment = this.toMoment;
        } else {
          //from moment selected from other calendar. Adjust both calendar so they
          //display properly
          this.$.from.toMoment = event.detail;
          this.$.to.fromMoment = this.$.from.fromMoment;
          this.$.to.toMoment = event.detail;
          this.set('toMoment', event.detail);
        }
        this._setRangeFromMoment();
      }
    },

    _areConsecutiveMonth: function(fromBaseDate, toBaseDate) {
      if(fromBaseDate && toBaseDate) {
        return moment(fromBaseDate).isSame(moment(toBaseDate).subtract(1, 'months'), 'month');
      } else {
        return false;
      }
    },

    _fromBaseDateChanged: function() {
      //don't allow the 'to' calendar to choose dates before 1 month after 'from' calendar
      if(this.$.from.isAtSelectionLevel) {
        this.$.to.blockDatesBefore = moment(this.fromBaseDate).add(1, 'month').startOf('month');
      }
    },

    _toBaseDateChanged: function() {
      //don't allow the 'to' calendar to choose dates before 1 month after 'from' calendar
      if(this.$.to.isAtSelectionLevel) {
        this.$.from.blockDatesAfter = moment(this.toBaseDate).subtract(1, 'month').endOf('month');
      }
    },
    /**
     * Open the modal
     */
    open: function() {
      if(this._isClosed()) {
        this.toggleAttribute('hidden', false);
      }
    },
    /**
     * Close the modal
     */
    close: function() {
      this.toggleAttribute('hidden', true);
    },

    _closeAndReturnFocus: function() {
      this.close();
      this.fire('px-modal-close-clicked');
    },

    _isClosed: function() {
      return this.hidden;
    },

  });
</script>
