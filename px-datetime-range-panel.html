<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../px-calendar-picker/px-calendar-picker.html"/>
<link rel="import" href="../px-datetime-common/px-datetime-presets.html"/>
<link rel="import" href="../px-datetime-common/px-datetime-buttons.html"/>
<link rel="import" href="../px-datetime-common/px-datetime-button-behavior.html"/>
<link rel="import" href="../px-datetime-common/px-datetime-imports.html"/>
<link rel="import" href="../px-datetime-field/px-datetime-field.html"/>
<link rel="import" href="../px-datetime-common/px-datetime-range-behavior.html"/>

<!--
Rangepicker modal component.

##### Usage

    <px-datetime-range-panel from={{...}} to={{...}}>
    </px-datetime-range-panel>
-->
<dom-module id="px-datetime-range-panel">
  <link rel="import" type="css" href="css/px-datetime-range-panel.css"/>
  <template>
    <div class=overlay></div>
    <div id="rangepickerModal" class="rangepicker__box inline--flex flex--col">
      <!-- Calendar + time inputs + presets -->
      <div class="flex">
        <!-- Calendars + time inputs -->
        <div class="flex--item flex--column">
          <!-- the two calendars -->
          <div class="flex flex--center">
            <div class="flex--item rangepicker__box__calendar">
              <px-calendar-picker
              id="from"
              hide-next-button="{{_areConsecutiveMonth(fromBaseDate, toBaseDate)}}"
              block-future-dates="{{blockFutureDates}}"
              base-date="{{fromBaseDate}}"
              time-zone="{{timeZone}}">
              </px-calendar-picker>
            </div>
            <template is="dom-if" if="{{!_areConsecutiveMonth(fromBaseDate, toBaseDate)}}">
              <div class="verticalDivider flex--item">
              </div>
            </template>
            <div class="flex--item rangepicker__box__calendar">
              <px-calendar-picker
                id="to"
                hide-previous-button="{{_areConsecutiveMonth(fromBaseDate, toBaseDate)}}"
                block-future-dates="{{blockFutureDates}}"
                base-date="{{toBaseDate}}"
                time-zone="{{timeZone}}">
              </px-calendar-picker>
            </div>
          </div>
          <!-- The two time inputs -->
          <template is="dom-if" if="{{showTime}}">
            <div class="horizontalDivider"></div>
            <div class="flex flex--center u-m">
              <px-datetime-field
                id="time"
                class="flex__item--middle u-mr- box__time"
                moment-obj="{{fromMoment}}"
                hide-icon
                hide-date
                show-time
                time-is-valid="{{_timeIsValid}}"
                time-format="{{timeFormat}}">
              </px-datetime-field>
              <div class="flex__item--middle largeFont">-</div>
              <px-datetime-field
                id="time"
                class="flex__item--middle u-ml- box__time"
                moment-obj="{{toMoment}}"
                hide-icon
                hide-date
                show-time
                time-is-valid="{{_timeIsValid}}"
                time-format="{{timeFormat}}">
              </px-datetime-field>
            </div>
          </template>
        </div>
        <!-- the presets -->
        <template is="dom-if" if="{{!hidePresets}}">
          <px-datetime-presets id="presets" class="flex flex--col border--left u-p+" preset-ranges="{{presetRanges}}">
          </px-datetime-presets>
        </template>
      </div>
      <template is="dom-if" if="{{showButtons}}">
        <div class="horizontalDivider"></div>
        <div class="flex flex--row--rev u-m-">
          <px-datetime-buttons
            class="flex__item--bottom"
            is-submit-button-valid="{{_isTimeOk}}"
            submit-text="Apply">
          </px-datetime-buttons>
        </div>
      </template>
    </div>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-datetime-range-panel',
    behaviors: [
      pxDatetimeRangeBehavior,
      pxDatetimeButtonBehavior],

    properties: {

      /**


       * (optional)
       *
       * Reflects the date currently used by the 'from' calendar to determine what it should
       * be showing, i.e what month, year or year range. ISO8601 string
       *
       * @default 1 month before now
       */
      fromBaseDate: {
        type: String,
        value: function() { return moment.tz(moment(), this.timezone).subtract(1,'months').toISOString();},
        observer: '_fromBaseDateChanged'
      },
      /**
       * (optional)
       *
       * Reflects the date currently used by the 'to' calendar to determine what it should
       * be showing, i.e what month, year or year range. ISO8601 string
       *
       * @default now
       */
      toBaseDate: {
        type: String,
        observer: '_toBaseDateChanged'
      },
      /**
       * True if the modal is hidden.  Must be declared as a property to reference (below) in IE 10.
       * @private
       */
      hidden: {
        type: Boolean
      },
      /**
       * (optional)
       * If set the presets won't be shown
       */
      hidePresets: {
        type: Boolean,
        value: false
      },
      /**
       * (optional)
       *
       * The preset date/time ranges to be displayed.
       *
       *```
       *   [
       *    {
       *      "displayText": "Last 5 Minutes",
       *      "startDateTime": "2013-02-04T22:44:30.652Z",
       *      "endDateTime": "2013-02-04T22:49:30.652Z"
       *    },
       *    {
       *      "displayText": "Last 12 Hours",
       *      "startDateTime": "2013-02-04T10:44:30.652Z",
       *      "endDateTime": "2013-02-04T22:49:30.652Z"
       *    }
       *   ]
       * ```
       *
       * @default Today + Yesterday + Last 7 Days + This Month + Last Month
       */
      presetRanges: {
        type: Object,
        value: function() {
          var now = moment();
          return [
            {
              "displayText": "Today",
              "startDateTime": now,
              "endDateTime": now
            },
            {
              "displayText": "Yesterday",
              "startDateTime": now.clone().subtract(1, 'day'),
              "endDateTime": now.clone().subtract(1, 'day')
            },
            {
              "displayText": "Last 7 Days",
              "startDateTime": now.clone().subtract(7, 'days'),
              "endDateTime": now
            },
            {
              "displayText": "This Month",
              "startDateTime": now.clone().startOf('month'),
              "endDateTime": now.clone().endOf('month')
            },
            {
              "displayText": "Last Month",
              "startDateTime": now.clone().subtract(1, 'months').startOf('month'),
              "endDateTime": now.clone().subtract(1, 'months').endOf('month')
            }
          ]
        }
      },
      /**
       * Whether time should be shown
       *
       */
      showTime: {
        type: Boolean,
        value: false
      },
      /**
       * Moment format used for the time
       *
       */
       timeFormat: {
        type: String,
        value: 'HH:mm:ss A'
      },
    },
    ready: function() {
      var fromHandler = this._fromPicked.bind(this),
          toHandler = this._toPicked.bind(this),
          presetHandler = this._presetSelected.bind(this);

      this.$.from.addEventListener('px-date-selected', fromHandler);
      this.$.to.addEventListener('px-date-selected', toHandler);
      this.addEventListener('px-preset-selected', presetHandler);
    },

    _presetSelected: function(e) {
      var start = moment.tz(e.detail.startDateTime, this.timeZone),
          end = moment.tz(e.detail.endDateTime, this.timeZone);

      //show appropriate month
      this.$.from._momentBaseDate = start.clone();
      if(end.isAfter(start.clone().add(1, 'months'), 'month')) {
        this.$.to._momentBaseDate = end.clone();
      } else {
        this.$.to._momentBaseDate = start.clone().add(1, 'months');
      }

      this.$.from.fromMoment = start.clone();
      this.$.from.toMoment = end.clone();
      this.$.to.fromMoment = start.clone();
      this.$.to.toMoment = end.clone();

      this.set('fromMoment', this._preserveTime(this.fromMoment, start.clone()));
      this.set('toMoment', this._preserveTime(this.toMoment, end.clone()));

      this._setRangeFromMoment();
    },

    _resetRange: function(rangeObject) {
      //order maters
      rangeObject.toMoment = null;
      rangeObject.fromMoment = null;
    },

    _rangeIsSelected: function() {
      return (this.$.from.fromMoment && this.$.to.toMoment) ||
             (this.$.from.fromMoment && this.$.from.toMoment) ||
             (this.$.to.fromMoment && this.$.to.toMoment);
    },

    _fromPicked: function(event) {

      //reset if needed
      if(this._rangeIsSelected()) {
        this._resetRange(this.$.to);
      }
      if(!this.hidePresets) {
        this.$$('px-datetime-presets').selectedItem = null;
      }

      //nothing selected, assume it's going to be the start date
      if(!this.$.from.toMoment && !this.$.to.toMoment && !this.$.to.fromMoment) {
        this.set('fromMoment', this._preserveTime(this.fromMoment, event.detail));
      } else {

        if(this.$.from.toMoment) {
          //range is picked solely on 'from' calendar

          //swap dates if needed
          if(event.detail.isBefore(this.fromMoment)) {

            this.set('toMoment', this._preserveTime(this.toMoment, this.fromMoment.clone()));
            this.set('fromMoment', this._preserveTime(this.fromMoment, event.detail));
          } else {
            this.set('toMoment', this._preserveTime(this.toMoment, event.detail));
          }

          //make sure 'to' calendar is aware of the range as well
          this.$.to.fromMoment = this.fromMoment;
          this.$.to.toMoment = this.toMoment;
        } else {
          //'to' moment selected from other calendar. Adjust both calendar so they
          //display properly
          this.$.to.toMoment = this.toMoment;
          this.$.to.fromMoment = event.detail;
          this.$.from.toMoment = this.toMoment;
          this.set('fromMoment', this._preserveTime(this.fromMoment, event.detail));
        }
      }
    },

    _toPicked: function(event) {

      //reset if needed
      if(this._rangeIsSelected()) {
        this._resetRange(this.$.from);
      }
      if(!this.hidePresets) {
        this.$$('px-datetime-presets').selectedItem = null;
      }

      //nothing selected, assume it's going to be the end date
      if(!this.$.from.toMoment && !this.$.to.toMoment && !this.$.from.fromMoment) {

        this.set('toMoment', this._preserveTime(this.toMoment, event.detail));
      } else {

        if(this.$.to.toMoment) {
          //range is picked solely on 'to' calendar

          //swap dates if needed
          if(event.detail.isAfter(this.toMoment)) {

            this.set('fromMoment', this._preserveTime(this.fromMoment, this.toMoment.clone()));
            this.set('toMoment', this._preserveTime(this.toMoment, event.detail));
          } else {
            this.set('fromMoment', this._preserveTime(this.fromMoment, event.detail));
          }
          //make sure both calendars reflects the right state
          this.$.to.toMoment = this.toMoment;
          this.$.to.fromMoment = this.fromMoment;
          this.$.from.fromMoment = this.fromMoment;
          this.$.from.toMoment = this.toMoment;
        } else {
          //from moment selected from other calendar. Adjust both calendar so they
          //display properly
          this.$.from.toMoment = event.detail;
          this.$.to.fromMoment = this.$.from.fromMoment;
          this.$.to.toMoment = event.detail;
          this.set('toMoment', this._preserveTime(this.toMoment, event.detail));
        }
      }
    },

    _areConsecutiveMonth: function(fromBaseDate, toBaseDate) {
      if(fromBaseDate && toBaseDate) {
        return moment.tz(fromBaseDate, this.timeZone).isSame(moment.tz(toBaseDate, this.timeZone).subtract(1, 'months'), 'month');
      } else {
        return false;
      }
    },

    _fromBaseDateChanged: function() {
      //don't allow the 'to' calendar to choose dates before 1 month after 'from' calendar
      if(this.$.from.isAtSelectionLevel) {
        this.$.to.blockDatesBefore = moment.tz(this.fromBaseDate, this.timeZone).add(1, 'month').startOf('month');
      }
    },

    _toBaseDateChanged: function() {
      //don't allow the 'to' calendar to choose dates before 1 month after 'from' calendar
      if(this.$.to.isAtSelectionLevel) {
        this.$.from.blockDatesAfter = moment.tz(this.toBaseDate, this.timeZone).subtract(1, 'month').endOf('month');
      }
    },
    /**
     * Open the modal
     */
    open: function() {
      if(this._isClosed()) {
        this.toggleAttribute('hidden', false);
      }
    },
    /**
     * Close the modal
     */
    close: function() {
      this.toggleAttribute('hidden', true);
    },

    _closeAndReturnFocus: function() {
      this.close();
      this.fire('px-modal-close-clicked');
    },

    _isClosed: function() {
      return this.hidden;
    }
  });
</script>
